{
    "collab_server" : "",
    "contents" : "q1=function() {\n  cat(\"Explain the two ways a planning graph can be used to provide a \",\n      \"heuristic for A*. (2 marks)\\n\",sep=\"\")\n}\na1=function() {\n  cat(\"1. The max-level heuristic: The number of levels between the initil state layer (given by the state whose heuristic value is being estimated) and the first state layer where all goal literals present.\\n\")\n  cat(\"2. The set-level heuristic: The number of levels between the initil state layer (given by the state whose heuristic value is being estimated) and the first state layer where all goal literals present AND there are no mutexs between any pair of goal literals.\\n\")\n}\nq2=function() {\n  cat(\"What is PDDL? Explain all components of a PDDL problem. Be as \",\n      \"precise and concise as possible.  (4 marks)\\n\",sep=\"\")\n}\na2=function() {\n  cat(\"PDDL stands for planning domain definition language. It is used to \",\n    \"specify planning problems in a way that is easy to solve using \",\n    \"search-based techniques. It works with database semantics, such \",\n    \"that all objects are uniquely named.\\n\",sep=\"\")\n  cat(\"\\nThe components of PDDL are:\\n\")\n  cat(\"  1. States. These are lists of positive literals (where literals \",\n      \"are logically atomic statements - i.e. without 'and', 'or', 'if... \",\n      \"then', and 'not'). Negation is by ommission.\\n\",sep=\"\")\n  cat(\"  2. Actions. These contain lists of preconditions and effects. These \",\n    \"lists contain positive and negative literals and show what is required \",\n    \"to be true in a state for an action to be permitted, and what changes \",\n    \"are effected when an action is performed. Actions play the role of \",\n    \"transitions between states.\\n\")\n  cat(\"  3. Goal state specification. This is a list of positive and \",\n      \"negative literals specifying what must be true for a state to be \",\n      \"a goal state.\\n\")\n  cat(\"In addition, for a PDDL problem to be fully specified an initial state \",\n      \"must be given.\\n\")\n}\nq3=function(){\n  cat(\"Explain how the goals of AI are different in industry and academia compared with in computer games. (1 mark)\\n\")\n}\na3=function(){\n  cat(\"AI in industry and academic normally focuses on providing the optimal solution to problems posed. AI in computer games, on the other hand, normally uses AI to produce competitive or realistic characters and opponents as an aid to entertainment. Computer games do not want AI opponents to be impossible to beat!\\n\")\n}\nq4=function(){\n  cat(\"Under what conditions could a depth-first search FAIL to find a solution (in a finite search space with at most a single edge between any two nodes)? (1 mark)\")\n}\na4=function(){\n  cat(\"When the search space contains loops.\")\n}\nq5=function(){\n  cat(\"Explain iterated deepening. (2 marks)\\n\")\n}\na5=function(){\n  cat(\"Iterated deepening performs a depth first search to a designated depth controlled by a parameter t. \")\n  cat(\"States at this depth treated as if they had no outgoing transitions. \")\n  cat(\"The terminal depth parameter t is initially set to 1. If a depth constrained search terminates without finding the goal state, the terminal depth parameter is increased (typically by 1) and a new search is begun.\")\n}\nq6=function(){\n  cat(\"Greedy Hill Climb suffers from the problem of local optima. Name and provide a brief explanation of three alternative local search strategies covered in this course that attempt to overcome or minimize this problem. (3 marks)\\n\")\n}\na6=function(){\n  cat(\"Any three of these four answers is correct:\\n\")\n  cat(\"  1. Greedy Hill Climb with random restarts. Here the greedy hill climb is run repeatedly from random initial positions.\\n\")\n  cat(\"  2. Simulated Annealing. At each step a random neighbor of the current state is selected. If the neighbor has a higher fitness, the transition is made. \")\n  cat(    \"If not, the transition will be made with a probability equal to the neighbors fitness divided by the current nodes fitness multiplied by a temperature parameter. \")\n  cat(    \"The temperature parameter is initialized with the value 1 and is then reduced to 0 following a cooling schedule.\\n\")\n  cat(\"  3. Local Beam Search. Multiple initial nodes are selected, each known as a particle. Where we have n particles, at each search step all neighbors and current nodes of these n particles are placed in a candidate set, and the particles move to the n nodes in this set with the highest fitness values.\\n\")\n  cat(\"  4. Stochastic Local Beam Search. As local beam search, except that particles move to nodes in the candidate set probabilistically. Typically, a particle can move to an unoccupied candidate node with probability equal to the fitness of that node divided by the sum of the fitness values of all unoccupied nodes in the candidate set. Initially, all nodes in the candidate set are considered unoccupied (including current nodes). Once one particle moves to a node in the candidate set it is considered occupied.\\n\")\n}\n\nprepareTextQuestions=function() {\n  list(q1,q2,q3,q4,q5,q6)\n}\nprepareTextAnswers=function() {\n  list(a1,a2,a3,a4,a5,a6)\n}\nprepareTextQuestionMarks=function(){\n  c(2,4,1,1,2,3)\n}\nprepareTextQuestionHeadings=function(){\n  c(\"Planning Graphs\",\"PDDL\",\"AI in Computer Games\",\"Depth-First Search\",\"Iterated Deepening\",\"Local Search\")\n}\ngetTextQuestionMarks=function(seed,n){\n  set.seed(seed)\n  marks=prepareTextQuestionMarks()\n  q_=sample(length(marks),n)\n  sum(marks[q_])\n}\nmakeTextQuestions=function(seed=NA,answer=T,latex=F,n=1) {\n  if (!is.na(seed))\n    set.seed(seed)\n  qs=prepareTextQuestions()\n  as=prepareTextAnswers()\n  headings=prepareTextQuestionHeadings()\n  q_=sample(length(qs),n)\n  first=T\n  for (q in q_) {\n    if (latex) {\n      cat(\"\\\\clearpage\\n\")\n      cat(\"\\\\section{\",headings[q],\"}\\n\\n\")\n      qs[[q]]()\n    }\n    else {\n      if (first)\n        first=F\n      else\n        readline(\"Press Enter to see the next question...\")\n      qs[[q]]()\n    }\n    if (answer) {\n      readline(\"Press Enter to see a sample answer...\")\n      as[[q]]()\n    }\n  }\n}\n",
    "created" : 1512422669881.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3416738871",
    "id" : "E8D5A289",
    "lastKnownWriteTime" : 1512860827,
    "last_content_update" : 1512860827301,
    "path" : "C:/Users/Acer/Desktop/Dokument/AI/2017/AIExam/R/testQuestions.R",
    "project_path" : "R/testQuestions.R",
    "properties" : {
        "tempName" : "Untitled5"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
{
    "collab_server" : "",
    "contents" : "makeSchedulingProblem=function(actions=7){\n\n  start=list(\n    index=1,\n    name=\"Start\",\n    after=NA,\n    duration=0,\n    uses=c(),\n    consumes=paste(0,\"nails\")\n  )\n  partialOrder=list(start)\n  nailsMade=sample(c(0,-1,-1),3)\n  durations=seq(5,50,5)\n  for (i in 1:3) {\n    time=sample(durations,1)\n    use=sample(c(\"Saw\"),sample(0:1,1))\n    consume=nailsMade[i]\n    nails=\"nails\"\n    if (consume==1 || consume==-1)\n      nails=\"nail\"\n    nextAction=list(\n      index=length(partialOrder)+1,\n      name=paste(\"Action\",i),\n      after=1,\n      duration=time,\n      uses=use,\n      consumes=paste(consume,nails)\n    )\n    partialOrder=append(partialOrder,list(nextAction))\n  }\n\n  nailsUsed=sample(c(rep(0,actions-5),1,1))\n  for (i in 4:actions) {\n    pred=sample(2:i,sample(1:3,1))\n    time=sample(durations,1)\n    use=sample(c(\"Hammer\",\"Saw\"),sample(0:2))\n    consume=nailsUsed[i-3]\n    # Make sure consumtion always consistent\n    if (consume)\n      pred=union(pred,which(nailsMade==-1)+1)\n    nails=\"nails\"\n    if (consume==1 || consume==-1)\n      nails=\"nail\"\n    nextAction=list(\n      index=length(partialOrder)+1,\n      name=paste(\"Action\",i),\n      after=pred,\n      duration=time,\n      uses=use,\n      consumes=paste(consume,nails)\n      )\n    partialOrder=append(partialOrder,list(nextAction))\n  }\n  asPred=sapply(2:(actions+1),function(i) {\n    any(sapply(partialOrder,function(act)return(i %in% act$after)))\n  })\n\n  finish=list(\n    index=length(partialOrder)+1,\n    name=\"Finish\",\n    after=which(!asPred)+1,\n    duration=0,\n    uses=c(),\n    consumes=paste(0,\"nails\")\n  )\n  partialOrder=append(partialOrder,list(finish))\n  return (partialOrder)\n}\nunconstrainedSchedule=function(partialOrder){\n  ES=rep(NA,length(partialOrder))\n  LS=ES\n  for (action in partialOrder){\n    if (is.na(action$after[1]))\n      ES[action$index]=0\n    else {\n      ES[action$index]=max(sapply(action$after,function(pre){\n        ES[pre]+partialOrder[[pre]]$duration\n      }))\n    }\n  }\n  for (action in rev(partialOrder)) {\n    if (action$index==length(partialOrder))\n      LS[action$index]=ES[action$index]\n    else {\n      before=which(sapply(partialOrder,function(act){\n        action$index %in% act$after\n      }))\n      LS[action$index]=min(sapply(before,function(post){\n        LS[post]-action$duration\n      }))\n    }\n  }\n  slack=LS-ES\n  cat(\"\\nUnconstrained Schedule:\\n\")\n  for (i in 1:length(partialOrder)) {\n    cat(i,\". \",partialOrder[[i]]$name,\": ES=\",ES[i],\", LS=\",LS[i],\", Slack=\",slack[i],\"\\n\",sep=\"\")\n  }\n  list(ES=ES,LS=LS,slack=slack)\n}\n\nfirstConstrainedTime_=function(duration,timeMin,freeIntervals) {\n  time=0\n  done=FALSE\n  resources=length(freeIntervals)\n  sufficientIntervals=list()\n  for (resource in freeIntervals) {\n    good=sapply(resource,function(interval){\n      interval$to-max(interval$from,timeMin)>=duration\n    })\n    nextSufficientIntervals=resource[good]\n    if (length(nextSufficientIntervals)==0){\n      stop(\"Invalid schedule 5\")\n    }\n    for (i in 1:length(nextSufficientIntervals)) {\n      if (nextSufficientIntervals[[i]]$from<timeMin)\n        nextSufficientIntervals[[i]]$from=timeMin\n    }\n    sufficientIntervals=append(sufficientIntervals,list(nextSufficientIntervals))\n  }\n\n  for (interval in sufficientIntervals[[1]]) {\n    if (resources==1)\n      return(interval$from)\n    else {\n      for (interval2 in sufficientIntervals[[2]]) {\n        maxFrom=max(interval$from,interval2$from)\n        minTo=min(interval$to,interval2$to)\n        if (duration<=minTo-maxFrom) {\n          if (resources==2)\n            return (maxFrom)\n          else {\n            for (interval3 in sufficientIntervals[[3]]) {\n              maxFrom2=max(maxFrom,interval3$from)\n              minTo2=min(minTo,interval3$to)\n              if (duration<=minTo2-maxFrom2) {\n                  return (maxFrom2)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  stop(\"Invalid Schedule 1.\")\n}\nfirstConstrainedTime=function(duration,\n                              after,nails,hammer,saw,\n                              Durations,Times,Nails,Hammer,Saw) {\n  timeMin=max(Times[after]+Durations[after])\n  if (is.na(after[1]))\n    timeMin=0\n  if (nails>0) {\n    if (length(Nails)==0) {\n      stop(\"Invalid schedule 2.\")\n    }\n    nailTimes=list()\n    nailCount=0\n    for (event in Nails) {\n      if (event$effect==-1) {\n        # A nail is made\n        nailCount=nailCount+1\n        if (length(nailTimes)==0 ||\n            nailTimes[[length(nailTimes)]]$to!=Inf) {\n          nailTimes=append(nailTimes,list(list(from=event$time,to=Inf)))\n        }\n      }\n      else {\n        # A nail is used\n        nailCount=nailCount-1\n        if (nailCount<0) {\n          stop(\"Invalid schedule 3.\")\n        }\n        else if (nailCount==0) {\n          if (length(nailTimes)==0) {\n            stop(\"Invalid schedule 4.\")\n          }\n          nailTimes[[length(nailTimes)]]$to=event$time\n        }\n      }\n    }\n    if (hammer) {\n      if (saw) {\n        # Need a nail, hammer and saw\n        return (firstConstrainedTime_(duration,timeMin,list(nailTimes,Hammer,Saw)))\n      }\n      else {\n        # Need a nail and hammer\n        return (firstConstrainedTime_(duration,timeMin,list(nailTimes,Hammer)))\n      }\n    }\n    else if (saw) {\n      # Need a nail and saw\n      return (firstConstrainedTime_(duration,timeMin,list(nailTimes,Saw)))\n    }\n    else {\n      # Need a nail\n      return (firstConstrainedTime_(duration,timeMin,list(nailTimes)))\n    }\n  }\n  else if (hammer) {\n    if (saw) {\n      # Need a hammer and saw\n      return (firstConstrainedTime_(duration,timeMin,list(Hammer,Saw)))\n    }\n    else {\n      # Need a hammer\n      return (firstConstrainedTime_(duration,timeMin,list(Hammer)))\n    }\n  }\n  else if (saw) {\n    # Need a saw\n    return (firstConstrainedTime_(duration,timeMin,list(Saw)))\n  }\n  else {\n    # Needs nothing\n    return (timeMin)\n  }\n}\nconstrainedSchedule=function(partialOrder,times) {\n  toDo=1:length(partialOrder)\n  Times=rep(NA,length(partialOrder))\n  Durations=sapply(partialOrder,function(act)act$duration)\n  Nails=list() # Element gives time and effect (+1,-1) of event\n  # Element gives start and stop of resource being free\n  Hammer=list(list(from=0,to=Inf))\n  Saw=list(list(from=0,to=Inf))\n  while (length(toDo)>0) {\n    predDone=sapply(partialOrder,function(action){\n      is.na(action$after) || !any(is.na(Times[action$after]))\n    })\n    posActions=which(1:length(partialOrder)%in%toDo &\n                       predDone )\n    nextAction=posActions[which(times$slack[posActions]==min(times$slack[posActions]))][1]\n    after=partialOrder[[nextAction]]$after\n    nails=0\n    if (partialOrder[[nextAction]]$consumes==\"1 nail\")\n      nails=1\n    else if  (partialOrder[[nextAction]]$consumes==\"-1 nail\")\n      nails=-1\n    saw=\"Saw\"%in%partialOrder[[nextAction]]$uses\n    hammer=\"Hammer\"%in%partialOrder[[nextAction]]$uses\n    time=firstConstrainedTime(partialOrder[[nextAction]]$duration,\n                              after,nails,hammer,saw,\n                              Durations,Times,Nails,Hammer,Saw)\n    if (nails!=0) {\n      eventTime=time\n      if (nails==-1)\n        eventTime=time+partialOrder[[nextAction]]$duration\n      nailEvent=list(list(time=eventTime,effect=nails))\n      if (length(Nails)==0)\n        Nails=append(Nails,nailEvent)\n      else{\n        # > rather than >= so uses go after productions at same time\n        nailTimes=sapply(Nails,function(event)event$time>eventTime)\n        #nailTimes=sapply(Nails,function(event)event$time>=eventTime)\n        if (!any(nailTimes))\n          Nails=append(Nails,nailEvent)\n        else {\n          cutIndex=which.max(nailTimes)\n          if (cutIndex==1) {\n            Nails=append(nailEvent,Nails)\n          }\n          else {\n            Nails=append(append(Nails[1:(cutIndex-1)],nailEvent),Nails[cutIndex:length(Nails)])\n          }\n        }\n      }\n    }\n    if (saw) {\n      sawTimes=sapply(Saw,function(event)event$to>=time)\n      cutIndex=which.max(sawTimes)\n      newEvent1=Saw[[cutIndex]]\n      newEvent1$to=time\n      newEvent2=Saw[[cutIndex]]\n      newEvent2$from=time+partialOrder[[nextAction]]$duration\n      newEvent=list()\n      if (newEvent1$from!=newEvent1$to)\n        newEvent=append(newEvent,list(newEvent1))\n      if (newEvent2$from!=newEvent2$to)\n        newEvent=append(newEvent,list(newEvent2))\n      if (cutIndex==1) {\n        if (length(Saw)==1)\n          Saw=newEvent\n        else\n          Saw=append(newEvent,Saw[2:length(Saw)])\n      }\n      else if (cutIndex==length(Saw)) {\n        Saw=append(Saw[1:(length(Saw)-1)],newEvent)\n      }\n      else {\n        Saw=append(append(Saw[1:(cutIndex-1)],newEvent),Saw[(cutIndex+1):length(Saw)])\n      }\n    }\n    if (hammer) {\n      hammerTimes=sapply(Hammer,function(event)event$to>=time)\n      cutIndex=which.max(hammerTimes)\n      newEvent1=Hammer[[cutIndex]]\n      newEvent1$to=time\n      newEvent2=Hammer[[cutIndex]]\n      newEvent2$from=time+partialOrder[[nextAction]]$duration\n      newEvent=list()\n      if (newEvent1$from!=newEvent1$to)\n        newEvent=append(newEvent,list(newEvent1))\n      if (newEvent2$from!=newEvent2$to)\n        newEvent=append(newEvent,list(newEvent2))\n      if (cutIndex==1) {\n        if (length(Hammer)==1)\n          Hammer=newEvent\n        else\n          Hammer=append(newEvent,Hammer[2:length(Hammer)])\n      }\n      else if (cutIndex==length(Hammer)) {\n        Hammer=append(Hammer[1:(length(Hammer)-1)],newEvent)\n      }\n      else {\n        Hammer=append(append(Hammer[1:(cutIndex-1)],newEvent),Hammer[(cutIndex+1):length(Hammer)])\n      }\n    }\n    Times[nextAction]=time\n    toDo=toDo[-which(toDo==nextAction)]\n  }\n\n  cat(\"\\nConstrained Schedule:\\n\")\n  cat(\"Action Start Times:\\n\")\n  for (i in 1:length(Times)) {\n    cat(i,\". \",partialOrder[[i]]$name,\": \",Times[i],\"\\n\",sep=\"\")\n  }\n  cat(\"Nail Consumption:\\n\")\n  for (i in 1:length(Nails)) {\n    cat(i,\". Time: \",Nails[[i]]$time,\", Effect: \",Nails[[i]]$effect,\"\\n\",sep=\"\")\n  }\n  cat(\"Saw Use:\\n\")\n  cnt=0\n  for (i in 1:length(Saw)) {\n    if (cnt==0) {\n      if (Saw[[i]]$from!=0) {\n        cnt=cnt+1\n        cat(cnt,\". From: 0, To: \",Saw[[i]]$from,\"\\n\",sep=\"\")\n      }\n    }\n    else {\n      cat(\", To: \",Saw[[i]]$from,\"\\n\",sep=\"\")\n    }\n    if (Saw[[i]]$to!=Inf) {\n      cnt=cnt+1\n      cat(cnt,\". From: \",Saw[[i]]$to,sep=\"\")\n    }\n  }\n  cat(\"Hammer Use:\\n\")\n  cnt=0\n  for (i in 1:length(Hammer)) {\n    if (cnt==0) {\n      if (Hammer[[i]]$from!=0) {\n        cnt=cnt+1\n        cat(cnt,\". From: 0, To: \",Hammer[[i]]$from,\"\\n\",sep=\"\")\n      }\n    }\n    else {\n      cat(\", To: \",Hammer[[i]]$from,\"\\n\",sep=\"\")\n    }\n    if (Hammer[[i]]$to!=Inf) {\n      cnt=cnt+1\n      cat(cnt,\". From: \",Hammer[[i]]$to,sep=\"\")\n    }\n  }\n}\n\nmakeQuestionSchedule=function(seed=NA,answer=T,latex=F) {\n  if(!is.na(seed))\n    set.seed(seed)\n  partialOrder=makeSchedulingProblem()\n  if (latex) {\n    cat(\"\\\\clearpage\\n\")\n    cat(\"\\\\section{Scheduling}\\n\\n\")\n    cat(\"Provide a complete resource constrained schedule for the actions found in Table~\\\\ref{schActions}. (4 marks)\\n\")\n\n    cat(\"\\\\begin{table}[h!]\\n\")\n    cat(\"\\\\caption{Actions}\\n\")\n    cat(\"\\\\label{schActions}\\n\",sep=\"\")\n    cat(\"\\\\begin{center}\\n\")\n    cat(\"\\\\begin{tabular}{ |c|c|c|c|c|c| } \\n\")\n    cat(\"\\\\hline\\n\")\n    cat(\" Index & Action & Duration & Uses & Consumes & After \\\\\\\\\\n\")\n    cat(\"\\\\hline\\n\")\n    for (act in partialOrder) {\n      cat(act$index,\" & \",act$name,\" & \",act$duration,\n          \" &  \",paste(act$uses,collapse=\",\"),\n          \" & \",act$consumes,\n          \" & \",paste(act$after,collapse=\",\"),\"\\\\\\\\\\n\",sep=\"\")\n    }\n    cat(\"\\\\hline\\n\")\n    cat(\"\\\\end{tabular}\\n\")\n    cat(\"\\\\end{center}\\n\")\n    cat(\"\\\\end{table}\\n\")\n  }\n  else {\n    cat(\"\\nActions to schedule:\\n\")\n    for (act in partialOrder) {\n      cat(act$index,\". \",act$name,\"\\n  Duration: \",act$duration,\n          \"\\n  Uses: \",paste(act$uses,collapse=\",\"),\n          \"\\n  Consumes: \",act$consumes,\n          \"\\n  After: \",paste(act$after,collapse=\",\"),\"\\n\",sep=\"\")\n    }\n  }\n  if (answer){\n    ucTimes=unconstrainedSchedule(partialOrder)\n    constrainedSchedule(partialOrder,ucTimes)\n  }\n}\n",
    "created" : 1508102336116.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2925702645",
    "id" : "3E10B510",
    "lastKnownWriteTime" : 1512852451,
    "last_content_update" : 1512852451698,
    "path" : "C:/Users/Acer/Desktop/Dokument/AI/2017/AIExam/R/schedule.R",
    "project_path" : "R/schedule.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}